# -*- coding: utf-8 -*-

"""
5099. [파이썬 S/W 문제해결 기본] 6일차 - 피자 굽기
문제 내용
N개의 피자를 동시에 구울 수 있는 화덕이 있다. 피자는 치즈가 모두 녹으면 화덕에서 꺼내며, 치즈의 양은 피자마다 다르다.
1번부터 M번까지 M개의 피자를 순서대로 화덕에 넣을 때, 치즈의 양에 따라 녹는 시간이 다르기 때문에 꺼내지는 순서는 바뀔 수 있다.
주어진 조건에 따라 피자를 구울 때, 화덕에 가장 마지막까지 남아있는 피자 번호를 알아내는 프로그램을 작성하시오.
- 피자는 1번위치에서 넣거나 뺄 수 있다.
- 화덕 내부의 피자받침은 천천히 회전해서 1번에서 잠시 꺼내 치즈를 확인하고 다시 같은 자리에 넣을 수 있다.
- M개의 피자에 처음 뿌려진 치즈의 양이 주어지고, 화덕을 한 바퀴 돌 때 녹지않은 치즈의 양은 반으로 줄어든다. 이전 치즈의 양을 C라고 하면 다시 꺼냈을 때 C//2로 줄어든다.
- 치즈가 모두 녹아 0이 되면 화덕에서 꺼내고, 바로 그 자리에 남은 피자를 순서대로 넣는다.

[입력]
첫 줄에 테스트 케이스 개수 T가 주어진다.  1<=T<=50
다음 줄부터 테스트 케이스의 첫 줄에 화덕의 크기 N과 피자 개수 M이 주어지고, 다음 줄에 M개의 피자에 뿌려진 치즈의 양을 나타내는 Ci가 주어진다.
3<=N<=20, N<=M<=100, 1<=Ci<=20

[출력]
각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 번호를 출력한다.

최초 작성 2019.02.26 PBY
"""

# 제출 시 삭제할 부분
import sys
sys.stdin = open("C:/Users/student/Documents/week2/day1/Algorithms/190226_03_input.txt", "r")

T = int(input())
for tc in range(T):
    # 필요한 input
    N, M = list(map(int,input().split())) # 화덕 크기와 피자 개수
    cheeses = list(map(int, input().split())) # 피자별 치즈 개수
    oven = [0 for _ in range(N)] # 화덕

    # 사용한 피자와 화덕 안에 존재하는 피자 개수
    pizza = 0
    pizzanum = 0

    # 초기에 화덕에 피자를 다 넣고 시작 (N<=M 조건이 있으므로 문제 없음)
    for fire in range(N): # 오븐의 최대 크기까지 피자를 넣어줌
        pizza += 1 # 3번째 피자까지 사용함
        oven[fire] = pizza
        pizzanum += 1 # 오븐에 존재하는 피자 개수가 3개

    # peek 용 변수
    f = -1

    # 마지막 피자를 꺼낼 때까지 (오븐 내의 pizzanum이 0이 되면 while 종료)
    while pizzanum > 0:

        # 매번 다른 애가 원점으로 돌아왔다고 생각한다. (원점을 돌리는 개념)
        f += 1

        # 오븐이 비어있고, 지금 더 넣을 피자가 준비되어있으면 피자를 추가함
        if oven[f % N] == 0 and pizza < M:
            pizza += 1 # 다음 피자를 꺼내서
            oven[f % N] = pizza # 오븐에 넣어줌
            pizzanum += 1 # 들어간 피자 개수 증가, 오븐 크기만큼 최대 3개 (elif로 들어가니까 따로 조건문 안 넣음)

        # 오븐이 비어있지 않고 피자가 들어있으면, 치즈를 녹임
        elif oven[f % N] != 0:
            cheeses[oven[f % N]-1] //= 2 # 다 녹으면 알아서 0이 됨

            # 치즈를 녹였는데 다 녹았으면 피자를 꺼내줌
            if cheeses[oven[f % N]-1] == 0:
                ans = oven[f % N] # 출력을 위해 가장 마지막으로 꺼낸 피자를 저장
                oven[f % N] = 0 # 피자를 꺼냈으니 그 자리는 0으로 바꿔줌 (front와 rear 대신 이렇게 제어)
                pizzanum -= 1 # 오븐에 들어있는 피자의 개수는 1개가 줄어든다.
                f -= 1 # 다음에 빈 자리에 피자를 넣을 수 있게 f 가 늘어나지 않게 한다.

    # 출력
    print("#{} {}".format(tc+1, ans))


"""
코드 구현
front와 rear를 사용하려다가, 구현이 어렵고 굳이 필요가 없다는 것을 알고
peek 변수 하나로만 구현하고, 빼는 경우 그 자리를 0으로 대체했다.

에러 정리
0. pizza < M을 넣지 않았을 때, 화덕에 들어가는 피자가 무한정 늘어나는 오류 발생
인덱스 에러가 계속 떠서 리스트를 출력해보고 나서야 들어갈 수 있는 피자보다 더 많이 들어간 것을 알았다.

1. 첫 제출 후 3개 맞음
조건문을 잘못 써서 오븐이 비어있는데 피자가 있는 줄 알고 자꾸 꺼내줘서 문제가 생겼다.
첫 번째 코드는 문제가 많아서 아래의 변형을 거쳐 문제를 하나씩 해결했다.

2. 위 코드를 cheeses[] > 0  조건문을 하나 추가했더니 6개를 맞았다.
처음부터 치즈가 없는 피자도 존재하는 것 같다. (추측)

3. f -= 1 을 넣어서 피자를 뺀 위치에 다시 다음 피자를 넣을 수 있게 했더니 7개를 맞았다.
이것을 넣지 않았을 때, 내가 피자를 빼면 그 위치에 피자를 안 넣고 그 다음 위치로 건너뛰어 피자를 넣었다.
이것은 디버깅 대신 논리적으로 생각하다 찾아냈다.

4. elif로 피자가 오븐에 들어있는 경우만 피자를 녹이고 꺼내는 연산을 진행했더니 다 맞았다.
안 그러면 pizza = M이 된 순간부터 오븐이 비어있더라도 피자를 더 넣지 않고 꺼내기만 하게 된다.
엄밀히 논리적으로 찾아냈다기보다 코드를 깔끔하게 정리하다가 우연히 해결되었다.

"""
